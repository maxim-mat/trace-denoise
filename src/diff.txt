diff --git a/src/denoisers/ConditionalUnetMatrixDenoiser.py b/src/denoisers/ConditionalUnetMatrixDenoiser.py
index ab0e950..2e3d729 100644
--- a/src/denoisers/ConditionalUnetMatrixDenoiser.py
+++ b/src/denoisers/ConditionalUnetMatrixDenoiser.py
@@ -148,7 +148,7 @@ class ConditionalUnetMatrixDenoiser(nn.Module):
 
         # self.outc_mat_linear = nn.Linear(64 * max_input_dim, 64)
         # self.outc_mat = nn.Linear(64, self.transition_dim * self.transition_dim)
-        self.outc_mat = nn.Conv2d(64, out_ch + 1, kernel_size=1)
+        self.outc_mat = nn.Conv2d(64, 1, kernel_size=1)
         self.outc = nn.Conv1d(64, out_ch, kernel_size=1)
 
     def pos_encoding(self, t, channels):
@@ -398,7 +398,7 @@ class ConditionalUnetMatrixDenoiser(nn.Module):
             else:
                 x_hat, m_hat = self._forward_uncond_mat(x, self.transition_matrix, t)
                 if gt_m is not None:
-                    matrix_loss = self.matrix_loss(m_hat.view(x.shape[0], self.num_classes + 1, -1), 
+                    matrix_loss = self.matrix_loss(m_hat.view(x.shape[0], 1, -1), 
                                                    gt_m.view(gt_m.size(1), -1).repeat(m_hat.shape[0], 1, 1))
         else:
             if y is not None:
diff --git a/src/main.py b/src/main.py
index d544958..b86eb56 100644
--- a/src/main.py
+++ b/src/main.py
@@ -39,7 +39,7 @@ from utils.graph_utils import prepare_process_model_for_hetero_gnn
 from utils.initialization import initialize
 from utils import calculate_metrics
 from utils.pm_utils import discover_dk_process, remove_duplicates_dataset, pad_to_multiple_of_n, conformance_measure
-from utils.graph_utils import prepare_process_model_for_gnn, get_process_model_reachability_graph_transition_matrix
+from utils.graph_utils import prepare_process_model_for_gnn, get_process_model_reachability_graph_transition_matrix, get_process_model_petri_net_transition_matrix
 
 warnings.filterwarnings("ignore")
 
@@ -94,10 +94,11 @@ def evaluate(diffuser, denoiser, test_loader, transition_matrix,
         x_hat_prob = torch.softmax(x_hat_logit, dim=2).to('cpu')
         x_hat_argmax = torch.argmax(x_hat_prob, dim=2)  # recovered deterministic traces tensor
 
-        alignment = np.mean(
-            conformance_measure(x_hat_argmax, process_model, init_marking, final_marking, cfg.activity_names,
-                                limit=1000, remove_duplicates=True, approximate=False)
-        )
+        #alignment = np.mean(
+        #    conformance_measure(x_hat_argmax, process_model, init_marking, final_marking, cfg.activity_names,
+        #                        limit=1000, remove_duplicates=True, approximate=False)
+        #)
+        alignment = 0
 
         try:
             auc = roc_auc_score(x_argmax_flat, x_hat_prob_flat, multi_class='ovr', average='macro')
@@ -200,10 +201,11 @@ def train(diffuser, denoiser, optimizer, train_loader, test_loader, transition_m
                     x_hat_argmax_flat = torch.argmax(x_hat_prob_flat, dim=1).to('cpu')
                     x_hat_prob = torch.softmax(x_hat, dim=2).to('cpu')
                     x_hat_argmax = torch.argmax(x_hat_prob, dim=2)
-                    train_epoch_alignment = np.mean(
-                        conformance_measure(x_hat_argmax, process_model, init_marking, final_marking,
-                                            cfg.activity_names, limit=1000, remove_duplicates=True, approximate=False)
-                    )
+                    #train_epoch_alignment = np.mean(
+                    #    conformance_measure(x_hat_argmax, process_model, init_marking, final_marking,
+                    #                        cfg.activity_names, limit=1000, remove_duplicates=True, approximate=False)
+                    #)
+                    train_epoch_alignment = 0
                     try:
                         auc = roc_auc_score(x_argmax_flat, x_hat_prob_flat, multi_class='ovr', average='micro')
                     except ValueError:
@@ -273,9 +275,9 @@ def main():
     dk_process_model, dk_init_marking, dk_final_marking = discover_dk_process(train_dataset, cfg,
                                                                               preprocess=remove_duplicates_dataset)
     if cfg.enable_matrix:
-        rg_nx, rg_transition_matrix = get_process_model_reachability_graph_transition_matrix(dk_process_model,
-                                                                                             dk_init_marking)
-        rg_transition_matrix = torch.tensor(rg_transition_matrix, device=cfg.device).float()
+        rg_nx, rg_transition_matrix = get_process_model_petri_net_transition_matrix(dk_process_model,
+                                                                                    dk_init_marking, dk_final_marking)
+        rg_transition_matrix = torch.tensor(rg_transition_matrix, device=cfg.device).unsqueeze(0).float()
         rg_transition_matrix = pad_to_multiple_of_n(rg_transition_matrix)
 
     train_loader = DataLoader(
